// =============================================================================
// Generated by efx_ipmgr
// Version: 2023.2.307
// IP Version: 5.4
// =============================================================================

////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2013-2023 Efinix Inc. All rights reserved.              
//
// This   document  contains  proprietary information  which   is        
// protected by  copyright. All rights  are reserved.  This notice       
// refers to original work by Efinix, Inc. which may be derivitive       
// of other work distributed under license of the authors.  In the       
// case of derivative work, nothing in this notice overrides the         
// original author's license agreement.  Where applicable, the           
// original license agreement is included in it's original               
// unmodified form immediately below this header.                        
//                                                                       
// WARRANTY DISCLAIMER.                                                  
//     THE  DESIGN, CODE, OR INFORMATION ARE PROVIDED “AS IS” AND        
//     EFINIX MAKES NO WARRANTIES, EXPRESS OR IMPLIED WITH               
//     RESPECT THERETO, AND EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES,  
//     INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF          
//     MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR    
//     PURPOSE.  SOME STATES DO NOT ALLOW EXCLUSIONS OF AN IMPLIED       
//     WARRANTY, SO THIS DISCLAIMER MAY NOT APPLY TO LICENSEE.           
//                                                                       
// LIMITATION OF LIABILITY.                                              
//     NOTWITHSTANDING ANYTHING TO THE CONTRARY, EXCEPT FOR BODILY       
//     INJURY, EFINIX SHALL NOT BE LIABLE WITH RESPECT TO ANY SUBJECT    
//     MATTER OF THIS AGREEMENT UNDER TORT, CONTRACT, STRICT LIABILITY   
//     OR ANY OTHER LEGAL OR EQUITABLE THEORY (I) FOR ANY INDIRECT,      
//     SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES OF ANY    
//     CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF      
//     GOODWILL, DATA OR PROFIT, WORK STOPPAGE, OR COMPUTER FAILURE OR   
//     MALFUNCTION, OR IN ANY EVENT (II) FOR ANY AMOUNT IN EXCESS, IN    
//     THE AGGREGATE, OF THE FEE PAID BY LICENSEE TO EFINIX HEREUNDER    
//     (OR, IF THE FEE HAS BEEN WAIVED, $100), EVEN IF EFINIX SHALL HAVE 
//     BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO 
//     NOT ALLOW THE EXCLUSION OR LIMITATION OF INCIDENTAL OR            
//     CONSEQUENTIAL DAMAGES, SO THIS LIMITATION AND EXCLUSION MAY NOT   
//     APPLY TO LICENSEE.                                                
//
////////////////////////////////////////////////////////////////////////////////

`define IP_UUID _df3514bca56d47498eab3aff58bc0e47
`define IP_NAME_CONCAT(a,b) a``b
`define IP_MODULE_NAME(name) `IP_NAME_CONCAT(name,`IP_UUID)
module bram_x_ratio (
input [9:0] addr,
output [15:0] rdata_a,
input clk
);
`IP_MODULE_NAME(efx_bram) #(
.ADDR_WIDTH_A (10),
.ADDR_WIDTH_B (10),
.RESET_A_ENABLE (1),
.RESET_B_ENABLE (1),
.RSTA_POLARITY (1),
.RSTB_POLARITY (1),
.FAMILY ("TITANIUM"),
.MEMORY_MODE ("SPEED"),
.WRITE_MODE_A ("READ_FIRST"),
.WRITE_MODE_B ("READ_FIRST"),
.OUTPUT_REG_A (0),
.OUTPUT_REG_B (0),
.MEMORY_TYPE ("SP_ROM"),
.GROUP_DATA_WIDTH_B (16),
.BYTEENA_ENABLE (0),
.BYTEENB_ENABLE (0),
.BYTEENA_POLARITY (1),
.BYTEENB_POLARITY (1),
.BYTEEN_WIDTH_A (1),
.BYTEEN_WIDTH_B (1),
.BYTEEN_ENABLE (0),
.BYTEEN_POLARITY (1),
.GROUP_DATA_WIDTH (16),
.BYTEEN_WIDTH (1),
.WIDTH_RATIO (4),
.GROUP_DATA_WIDTH_A (16),
.DATA_WIDTH_A (16),
.DATA_WIDTH_B (16),
.ADDREN_ENABLE (0),
.ADDREN_POLARITY (1),
.CLK_MODE (1),
.CLKA_POLARITY (1),
.CLKB_POLARITY (1),
.CLKE_POLARITY (1),
.CLKEA_POLARITY (1),
.CLKEA_ENABLE (1),
.RESET_OUTREG_A ("ASYNC"),
.RESET_OUTREG_B ("ASYNC"),
.RESET_RAM_B ("ASYNC"),
.WEA_ENABLE (1),
.WEA_POLARITY (1),
.WEB_ENABLE (1),
.WEB_POLARITY (1),
.RADDREN_ENABLE (1),
.RADDREN_POLARITY (1),
.WADDREN_ENABLE (1),
.WADDREN_POLARITY (1),
.RCLK_POLARITY (1),
.ADDREN_A_ENABLE (1),
.ADDREN_B_ENABLE (1),
.ADDRENA_POLARITY (1),
.ADDRENB_POLARITY (1),
.WE_ENABLE (1),
.WE_POLARITY (1),
.WCLKE_ENABLE (1),
.WCLKE_POLARITY (1),
.WCLK_POLARITY (1),
.RESET_RAM_A ("ASYNC"),
.RESET_RAM ("ASYNC"),
.CLK_POLARITY (1),
.OUTPUT_REG (1),
.RE_POLARITY (1),
.RE_ENABLE (0),
.WRITE_MODE ("READ_FIRST"),
.RESET_OUTREG ("ASYNC"),
.RESET_ENABLE (0),
.RST_POLARITY (1),
.CLKEB_POLARITY (1),
.CLKEB_ENABLE (1)
) u_efx_bram(
.addr ( addr ),
.rdata_a ( rdata_a ),
.clk ( clk )
);

endmodule

module `IP_MODULE_NAME(efx_bram) #(

parameter CLK_POLARITY      = 1'b1, 	//clk polarity;  0:falling edge; 1:rising edge
parameter CLKE_POLARITY     = 1'b1, 	//clke polarity for one clk mode; 0:active low; 1:active high
parameter CLKA_POLARITY     = 1'b1, 	//clk A polarity;  0:falling edge; 1:rising edge
parameter CLKEA_POLARITY    = 1'b1, 	//clke A polarity; 0:active low; 1:active high
parameter WEA_POLARITY	    = 1'b1, 	//we A polarity;    0:active low; 1:active high
parameter OUTPUT_REG_A   	= 1'b0, 	// Output register enable; 1:add pipe-line read register
parameter BYTEENA_POLARITY  = 1'b1,     // byteen polarity		0:active low; 1:active high 
parameter CLKB_POLARITY     = 1'b1, 	//clk A polarity;  0:falling edge; 1:rising edge
parameter CLKEB_POLARITY    = 1'b1, 	//clke A polarity; 0:active low; 1:active high
parameter WEB_POLARITY	    = 1'b1, 	//we B polarity;    0:active low; 1:active high
parameter OUTPUT_REG_B   	= 1'b0, 	// Output register enable; 1:add pipe-line read register
parameter BYTEENB_POLARITY  = 1'b1,     // byteen polarity		0:active low; 1:active high 
parameter WCLKE_POLARITY    = 1'b1, 	//wclke polarity; 0:active low; 1:active high
parameter WCLK_POLARITY     = 1'b1, 	//wclk polarity;  0:falling edge; 1:rising edge
parameter RCLK_POLARITY     = 1'b1, 	// rclk polarity; 0:falling edge; 1:rising edge
parameter WE_POLARITY	    = 1'b1, 	//we polarity;    0:active low; 1:active high
parameter RE_POLARITY       = 1'b1, 	// re polarity;	  0:active low  ; 1:active high
parameter OUTPUT_REG        = 1'b0, 	// Output register enable; 1:add pipe-line read register
parameter BYTEEN_POLARITY   = 1'b1,		//byteen polarity;    0:active low; 1:active high   
parameter WCLKE_ENABLE 		= 1'b1, 	//1: Enable  the port for waddren pin  ; 0: disable 
parameter WE_ENABLE 		= 1'b1,		//1: Enable  the port for WE pin ; 0: disable 
parameter RE_ENABLE 		= 1'b1,		//1: Enable  the port for RE pin ; 0: disable 
parameter BYTEEN_ENABLE 	= 1'b1,		//1: Enable  the port for Byteen pins ; 0: disable 
parameter RST_POLARITY 	    = 1'b1,    	// rst polarity
parameter RESET_RAM 	    = "ASYNC", 	// reset mode on ram;  "NONE": RST signals does not affect the RAM output.
										//					  "ASYNC": RAM output resets asynchronously to RCLK.
										//                     "SYNC": RAM output resets synchronously to RCLK. 
parameter RESET_OUTREG 	    = "ASYNC", 	// reset mode on output register
										//					   "NONE": RST signals does not affect the RAM output register		
										//					  "ASYNC": RAM output register resets asynchronously to RCLK.
parameter ADDREN_POLARITY   = 1'b1,    	// addren polarity
parameter RESET_ENABLE 		= 1'b1,		//1: Enable  the port for reset pin  ; 0: disable 
parameter ADDREN_ENABLE 	= 1'b1,		//1: Enable  the port for addren pin  ; 0: disable 
parameter CLK_MODE			= 2,		//1: ONE CLK Mode; CLK pin will provide the clock source to the memory
									    //2: TWO CLK Mode; wclk pin will provide the clock source for write operation ; rclk pin will provide the clock source for read operation
parameter WADDREN_POLARITY  = 1'b1,    	// waddren polarity
parameter RADDREN_POLARITY  = 1'b1,     // raddren polarity
parameter CLKEA_ENABLE 		= 1'b1, 	//1: Enalbe the port for clke_a pin  ; 0: dislable 
parameter WEA_ENABLE 		= 1'b1,		//1: Enable the port for we_a pin ; 0: disable 
parameter BYTEENA_ENABLE 	= 1'b1,		//1: Enable the port for Byteen_a pins ; 0: disable 
                                        //
parameter CLKEB_ENABLE 		= 1'b1, 	//1: Enalbe the port for clke_b pin  ; 0: dislable 
parameter WEB_ENABLE 		= 1'b1,		//1: Enable the port for we_b pin ; 0: disable 
parameter BYTEENB_ENABLE 	= 1'b1,		//1: Enable the port for Byteen_b pins ; 0: disable 
parameter RSTA_POLARITY 	= 1'b1,    	// rst A polarity
parameter RESET_RAM_A 	    = "ASYNC", 	// reset A mode on ram;  "NONE": RST signals does not affect the RAM output.
										//					  "ASYNC": RAM output resets asynchronously to RCLK.
										//                     "SYNC": RAM output resets synchronously to RCLK. 
parameter RESET_OUTREG_A 	= "ASYNC", 	// reset A mode on output register
										//					   "NONE": RST signals does not affect the RAM output register		
										//					  "ASYNC": RAM output register resets asynchronously to RCLK.
parameter ADDRENA_POLARITY  = 1'b1,    	// addrena polarity
parameter RSTB_POLARITY 	= 1'b1,    	// rst A polarity
parameter RESET_RAM_B 	    = "ASYNC", 	// reset A mode on ram;  "NONE": RST signals does not affect the RAM output.
										//					  "ASYNC": RAM output resets asynchronously to RCLK.
										//                     "SYNC": RAM output resets synchronously to RCLK. 
parameter RESET_OUTREG_B 	= "ASYNC", 	// reset A mode on output register
										//					   "NONE": RST signals does not affect the RAM output register		
										//					  "ASYNC": RAM output register resets asynchronously to RCLK.
parameter ADDRENB_POLARITY  = 1'b1,   	// addrenb polarity
parameter RESET_A_ENABLE 	= 1'b1,		//1: Enable the port for reset_a pin  ; 0: disable 
parameter ADDREN_A_ENABLE 	= 1'b1,		//1: Enable the port for addren_a pin  ; 0: disable 
parameter RESET_B_ENABLE 	= 1'b1,		//1: Enable the port for reset_b pin  ; 0: disable 
parameter ADDREN_B_ENABLE 	= 1'b1,		//1: Enable the port for addren_b pin  ; 0: disable 
parameter WADDREN_ENABLE 	= 1'b1,		//1: Enable the port for waddren pin  ; 0: disable 
parameter RADDREN_ENABLE 	= 1'b1,		//1: Enable the port for raddren pin  ; 0: disable 

parameter ADDR_WIDTH_A      = 3,
parameter DATA_WIDTH_A      = 16,
parameter ADDR_WIDTH_B      = 3,
parameter DATA_WIDTH_B      = 16,
parameter BYTEEN_WIDTH      = 2,
parameter BYTEEN_WIDTH_A    = 2,
parameter BYTEEN_WIDTH_B    = 2,
parameter MEMORY_TYPE		= "SP_RAM",  //1:sp_ram, 2:sdp_ram, 3:tdp_ram
parameter WRITE_MODE		= "READ_FIRST",
parameter WRITE_MODE_A		= "READ_FIRST",
parameter WRITE_MODE_B		= "READ_FIRST",
parameter FAMILY            = "TITANIUM",  //1:Titanium, 0:Trion
parameter GROUP_DATA_WIDTH  = 8,
parameter GROUP_DATA_WIDTH_A= 8,
parameter GROUP_DATA_WIDTH_B= 8,
parameter MEMORY_MODE       = "SPEED",  //1:speed, 2:area
parameter WIDTH_RATIO       = 4
)


(
//////////// data input/output ///////////////////
input wire [DATA_WIDTH_A-1:0] wdata_a,
input wire [DATA_WIDTH_B-1:0] wdata_b,
output wire [DATA_WIDTH_A-1:0] rdata_a,
output wire [DATA_WIDTH_B-1:0] rdata_b,

///////// Single Port RAM/ROM ports ////////////
input wire clk,
input wire [ADDR_WIDTH_A-1:0] addr,
input wire wclke,
input wire [BYTEEN_WIDTH-1:0] byteen,
input wire we,
input wire re,
//Titanium extra ports
input wire reset,
input wire addren,

//////////// Simple Dual Port RAM ports ///////////
input wire wclk,
input wire [ADDR_WIDTH_A-1:0] waddr,
input wire rclk,
input wire [ADDR_WIDTH_B-1:0] raddr,
//Titanium extra ports
input wire waddren,
input wire raddren,

//////////True Dual Port RAM/ROM ports ////////////////
input wire clke,
input wire clk_a, 
input wire clke_a,
input wire we_a,
input wire [BYTEEN_WIDTH_A-1:0] byteen_a,
input wire [ADDR_WIDTH_A-1:0 ] addr_a,
input wire clk_b, 
input wire clke_b,
input wire we_b,
input wire [BYTEEN_WIDTH_B-1:0] byteen_b,
input wire [ADDR_WIDTH_B-1:0 ] addr_b,
//Titanium extra ports
input wire reset_a,
input wire addren_a,
input wire reset_b,
input wire addren_b
);

generate
	if (MEMORY_TYPE == "SP_RAM") //Single Port RAM
	begin
		//if (BYTEEN_ENABLE == 1)
		//begin
		
	    `IP_MODULE_NAME(efx_single_port_ram) #(
	      .CLK_POLARITY    	(CLK_POLARITY   ),	
	      .WCLKE_POLARITY  	(WCLKE_POLARITY ),	
	      .WE_POLARITY	 	(WE_POLARITY	),	
	      .WRITE_MODE  	 	(WRITE_MODE  	),	
	      .RE_POLARITY     	(RE_POLARITY    ),	
	      .OUTPUT_REG      	(OUTPUT_REG     ),	
	      .BYTEEN_POLARITY 	(BYTEEN_POLARITY),	
	      .WCLKE_ENABLE 	(WCLKE_ENABLE 	),	
	      .WE_ENABLE 		(WE_ENABLE 		),	
	      .RE_ENABLE 		(RE_ENABLE 		),	
	      .BYTEEN_ENABLE 	(BYTEEN_ENABLE 	),
	      
	      .BYTEEN_WIDTH		(BYTEEN_WIDTH	),
	      .ADDR_WIDTH_A		(ADDR_WIDTH_A	),
	      .DATA_WIDTH_A		(DATA_WIDTH_A	),
	      
	      .FAMILY			(FAMILY			),
             
	         //Titanium extra paramters 
	      .RST_POLARITY 	(RST_POLARITY	), 	
	      .RESET_RAM 	    (RESET_RAM 	    ),
	      .RESET_OUTREG 	(RESET_OUTREG 	),
	      .ADDREN_POLARITY  (ADDREN_POLARITY),
	      .RESET_ENABLE 	(RESET_ENABLE 	),
	      .ADDREN_ENABLE 	(ADDREN_ENABLE 	)
        ) 
	    spram_inst
	    (
	      .clk		(clk	),
	      .addr		(addr	),
	      .wclke	(wclke	),
	      .byteen	(byteen	),
	      .we		(we		),
	      .wdata_a	(wdata_a),
	      .re		(re		),
	      .rdata_a	(rdata_a),
	      .reset	(reset	),
	      .addren	(addren	)
	    );
		//end
		//else if (BYTEEN_ENABLE == 0) 
		//begin
		//	
		//	`IP_MODULE_NAME(efx_single_port_ram) #(
		//      .CLK_POLARITY    	(CLK_POLARITY   ),	
	    //      .WCLKE_POLARITY  	(WCLKE_POLARITY ),	
	    //      .WE_POLARITY	 	(WE_POLARITY	),	
	    //      .WRITE_MODE  	 	(WRITE_MODE  	),	
	    //      .RE_POLARITY     	(RE_POLARITY    ),	
	    //      .OUTPUT_REG      	(OUTPUT_REG     ),	
	    //      .BYTEEN_POLARITY 	(BYTEEN_POLARITY),	
	    //      .WCLKE_ENABLE 	(WCLKE_ENABLE 	),	
	    //      .WE_ENABLE 		(WE_ENABLE 		),	
	    //      .RE_ENABLE 		(RE_ENABLE 		),	
	    //      .BYTEEN_ENABLE 	(BYTEEN_ENABLE 	),
	    //      
	    //      .BYTEEN_WIDTH		(BYTEEN_WIDTH	),
		//      .ADDR_WIDTH_A		(ADDR_WIDTH_A	),
		//      .DATA_WIDTH_A		(DATA_WIDTH_A	),
		//      .DATA_WIDTH_B		(DATA_WIDTH_B	),
		//      
		//      .FAMILY			(FAMILY			),
        //      
	    //      //Titanium extra paramters 
	    //      .RST_POLARITY 	(RST_POLARITY	), 	
	    //      .RESET_RAM 	    (RESET_RAM 	    ),
	    //      .RESET_OUTREG 	(RESET_OUTREG 	),
	    //      .ADDREN_POLARITY  (ADDREN_POLARITY),
	    //      .RESET_ENABLE 	(RESET_ENABLE 	),
	    //      .ADDREN_ENABLE 	(ADDREN_ENABLE 	)
        //    ) 
		//    spram_inst
		//    (
		//      .clk		(clk	),
		//      .addr		(addr	),
		//      .wclke	(wclke	),
		//      .we		(we		),
		//      .wdata_a(wdata_a),
		//      .re		(re		),
		//      .rdata_a(rdata_a),
		//      .reset	(reset	),
		//      .addren	(addren	)
		//    );
		//end
	end
	else if (MEMORY_TYPE == "SDP_RAM") //Simple Dual Port RAM
	begin
		
		`IP_MODULE_NAME(efx_simple_dual_port_ram) #(
	      .CLK_POLARITY    	(CLK_POLARITY   ),
	      .WCLK_POLARITY    (WCLK_POLARITY  ),		
	      .WCLKE_POLARITY  	(WCLKE_POLARITY ),	
	      .WE_POLARITY	 	(WE_POLARITY	),	
	      .WRITE_MODE  	 	(WRITE_MODE  	),	
	      
	      .RCLK_POLARITY    (RCLK_POLARITY  ),	
	      .RE_POLARITY     	(RE_POLARITY    ),	
	      .OUTPUT_REG      	(OUTPUT_REG     ),	
	      .BYTEEN_POLARITY 	(BYTEEN_POLARITY),
	      .CLK_MODE			(CLK_MODE),
	      .WCLKE_ENABLE 	(WCLKE_ENABLE 	),	
	      .WE_ENABLE 		(WE_ENABLE 		),	
	      .RE_ENABLE 		(RE_ENABLE 		),	
	      .BYTEEN_ENABLE 	(BYTEEN_ENABLE 	),
	      
	      .BYTEEN_WIDTH		(BYTEEN_WIDTH	),
		  .ADDR_WIDTH_A		(ADDR_WIDTH_A	),
		  .DATA_WIDTH_A		(DATA_WIDTH_A	),
		  .ADDR_WIDTH_B		(ADDR_WIDTH_B	),
		  .DATA_WIDTH_B		(DATA_WIDTH_B	),
		  
		  .FAMILY			(FAMILY			),
          
	      //Titanium extra paramters 
	      .RST_POLARITY 	(RST_POLARITY	), 	
	      .RESET_RAM 	    (RESET_RAM 	    ),
	      .RESET_OUTREG 	(RESET_OUTREG 	),
	      .RADDREN_POLARITY (RADDREN_POLARITY),
	      .WADDREN_POLARITY (WADDREN_POLARITY),
	      .RESET_ENABLE 	(RESET_ENABLE 	),
	      .RADDREN_ENABLE 	(RADDREN_ENABLE ),
	      .WADDREN_ENABLE 	(WADDREN_ENABLE)
	    )
	      sdpram_inst
		(
		  .clk		(clk		),
		  .wclk		(wclk		),
		  .wclke	(wclke		),
		  .byteen	(byteen		),
		  .we		(we			),
		  .waddr	(waddr		),
		  .wdata_a	(wdata_a	),
		  .rclk		(rclk		),
		  .re		(re			),
		  .raddr	(raddr		),
		  .rdata_b	(rdata_b	),
		  .reset	(reset		),
		  .waddren	(waddren	),
		  .raddren	(raddren	)
		  
		);
		
	end
	else if (MEMORY_TYPE == "TDP_RAM") //True Dual Port RAM
	begin
		
		`IP_MODULE_NAME(efx_true_dual_port_ram) #(
	
	      //Trion and Titanium parameters
	      .CLK_POLARITY    (CLK_POLARITY	),
	      .CLKE_POLARITY   (CLKE_POLARITY	),					
	      .CLKA_POLARITY   (CLKA_POLARITY   ),
	      .CLKEA_POLARITY  (CLKEA_POLARITY  ),
	      .WEA_POLARITY	   (WEA_POLARITY	),
	      .WRITE_MODE_A    (WRITE_MODE_A    ),
	      .OUTPUT_REG_A    (OUTPUT_REG_A    ),
	      .BYTEENA_POLARITY(BYTEENA_POLARITY),
	      .CLKB_POLARITY   (CLKB_POLARITY   ),
	      .CLKEB_POLARITY  (CLKEB_POLARITY  ),
	      .WEB_POLARITY	   (WEB_POLARITY    ),
	      .WRITE_MODE_B    (WRITE_MODE_B    ),
	      .OUTPUT_REG_B    (OUTPUT_REG_B    ),
	      .BYTEENB_POLARITY(BYTEENB_POLARITY),
	      
	      .BYTEEN_WIDTH_A	(BYTEEN_WIDTH_A	),
	      .BYTEEN_WIDTH_B	(BYTEEN_WIDTH_B	),
		  .ADDR_WIDTH_A		(ADDR_WIDTH_A	),
		  .DATA_WIDTH_A		(DATA_WIDTH_A	),
		  .ADDR_WIDTH_B		(ADDR_WIDTH_B	),
		  .DATA_WIDTH_B		(DATA_WIDTH_B	),
		  
		  .FAMILY			(FAMILY			),
	      
	      
	      //Port Enable  
	      .CLK_MODE		  (CLK_MODE		),			
	      .CLKEA_ENABLE   (CLKEA_ENABLE ),
	      .WEA_ENABLE 	  (WEA_ENABLE 	),	
	      .BYTEENA_ENABLE (BYTEENA_ENABLE ),   
	      .CLKEB_ENABLE   (CLKEB_ENABLE ),
	      .WEB_ENABLE 	  (WEB_ENABLE 	),	
	      .BYTEENB_ENABLE (BYTEENB_ENABLE ),
          
	      
	      //Titanium extra paramters 
	      .RSTA_POLARITY 	(RSTA_POLARITY 	   ),
	      .RESET_RAM_A 		(RESET_RAM_A 	   ),		  	
	      .RESET_OUTREG_A 	(RESET_OUTREG_A    ),
	      .ADDRENA_POLARITY (ADDRENA_POLARITY  ),
	      .RSTB_POLARITY 	(RSTB_POLARITY 	   ),
	      .RESET_RAM_B 	    (RESET_RAM_B 	   ),
	      .RESET_OUTREG_B 	(RESET_OUTREG_B    ),
	      .ADDRENB_POLARITY (ADDRENB_POLARITY  ),
          
	      //Port Enable  
	      .RESET_A_ENABLE 	(RESET_A_ENABLE ),
	      .ADDREN_A_ENABLE  (ADDREN_A_ENABLE),
	      .RESET_B_ENABLE 	(RESET_B_ENABLE ),
	      .ADDREN_B_ENABLE  (ADDREN_B_ENABLE)
	    ) 
	      tdpram_inst
		(
		  .clk		(clk	),
		  .clke		(clke	),
		  .clk_a	(clk_a	),
		  .clke_a	(clke_a	),
		  .we_a		(we_a	),
		  .byteen_a	(byteen_a),
		  .addr_a	(addr_a	),
		  .wdata_a	(wdata_a),
		  .rdata_a	(rdata_a),
		  .clk_b	(clk_b	),
		  .clke_b	(clke_b	),
		  .we_b		(we_b	),
		  .byteen_b	(byteen_b),
		  .addr_b	(addr_b	),
		  .wdata_b	(wdata_b),
		  .rdata_b	(rdata_b),
		  .reset_a	(reset_a),
		  .addren_a	(addren_a),
		  .reset_b	(reset_b),
		  .addren_b	(addren_b)
		  
		);
	end
	else if (MEMORY_TYPE == "SP_ROM") //Single Port ROM
	begin
		
		`IP_MODULE_NAME(efx_single_port_rom) #(
		
		  .CLK_POLARITY    	(CLK_POLARITY   ),	
	      .RE_POLARITY     	(RE_POLARITY    ),	
	      .OUTPUT_REG      	(OUTPUT_REG     ),	
	      .RE_ENABLE 		(RE_ENABLE 		),	
	      
	      .BYTEEN_WIDTH		(BYTEEN_WIDTH	),
		  .ADDR_WIDTH_A		(ADDR_WIDTH_A	),
		  .DATA_WIDTH_A		(DATA_WIDTH_A	),
		  .FAMILY           (FAMILY         ),
          
	      //Titanium extra paramters 
	      .RST_POLARITY 	(RST_POLARITY	), 	
	      .RESET_RAM 	    (RESET_RAM 	    ),
	      .RESET_OUTREG 	(RESET_OUTREG 	),
	      .ADDREN_POLARITY  (ADDREN_POLARITY),
	      .RESET_ENABLE 	(RESET_ENABLE 	),
	      .ADDREN_ENABLE 	(ADDREN_ENABLE 	)
	      
	    )
		sprom_inst
		(
		  .clk		(clk	),
		  .addr		(addr	),
		  .re		(re		),
		  .rdata_a	(rdata_a),
		  .reset	(reset	),
		  .addren	(addren)
		  
		);
	end
	else if (MEMORY_TYPE == "DP_ROM") //Dual Port ROM
	begin
		
		`IP_MODULE_NAME(efx_dual_port_rom) #(
	
	      //Trion and Titanium parameters
	      .CLK_POLARITY    ( CLK_POLARITY  ),
	      .CLKE_POLARITY   ( CLKE_POLARITY ),					
	      .CLKA_POLARITY   ( CLKA_POLARITY  ),
	      .CLKEA_POLARITY  ( CLKEA_POLARITY ),
	      
          .OUTPUT_REG_A    ( OUTPUT_REG_A   ),
	      .CLKB_POLARITY   ( CLKB_POLARITY  ),
	      .CLKEB_POLARITY  ( CLKEB_POLARITY ),
	      .OUTPUT_REG_B    ( OUTPUT_REG_B   ),
	      
	      
	      //Port Enable  
	      .CLK_MODE		(CLK_MODE		),			
	      .CLKEA_ENABLE (CLKEA_ENABLE 	),
	      .CLKEB_ENABLE (CLKEB_ENABLE 	),
	      
	      
	      //Titanium extra paramters 
	      .RSTA_POLARITY 	(RSTA_POLARITY 	   ),
	      .RESET_RAM_A 		(RESET_RAM_A 	   ),		  	
	      .RESET_OUTREG_A 	(RESET_OUTREG_A    ),
	      .ADDRENA_POLARITY (ADDRENA_POLARITY  ),
	      .RSTB_POLARITY 	(RSTB_POLARITY 	   ),
	      .RESET_RAM_B 	    (RESET_RAM_B 	   ),
	      .RESET_OUTREG_B 	(RESET_OUTREG_B    ),
	      .ADDRENB_POLARITY (ADDRENB_POLARITY  ),
          
	      //Port Enable  
	      .RESET_A_ENABLE 	(RESET_A_ENABLE ),
	      .ADDREN_A_ENABLE  (ADDREN_A_ENABLE),
	      .RESET_B_ENABLE 	(RESET_B_ENABLE ),
	      .ADDREN_B_ENABLE  (ADDREN_B_ENABLE),
	      
	      //DATA and ADDR
	      .DATA_WIDTH_A    (DATA_WIDTH_A),
	      .DATA_WIDTH_B    (DATA_WIDTH_B),
	      .ADDR_WIDTH_A    (ADDR_WIDTH_A),
	      .ADDR_WIDTH_B    (ADDR_WIDTH_B),
	      .FAMILY          (FAMILY)
	    )  
	      dprom_inst 
		(
		  .clk		(clk	),
		  .clke		(clke	),
		  .clk_a	(clk_a	),
		  .clke_a	(clke_a	),
		  .addr_a	(addr_a	),
		  .rdata_a	(rdata_a),
		  .clk_b	(clk_b	),
		  .clke_b	(clke_b	),
		  .addr_b	(addr_b	),
		  .rdata_b	(rdata_b),
		  .reset_a	(reset_a),
		  .addren_a	(addren_a),	
		  .reset_b	(reset_b),
		  .addren_b	(addren_b)
		  
		);
	end
endgenerate

endmodule























////////////////////////////////////////////////////////////////////////////
//           _____       
//          / _______    Copyright (C) 2013-2022 Efinix Inc. All rights reserved.
//         / /       \   
//        / /  ..    /   `IP_MODULE_NAME(bram_primitive).v
//       / / .'     /    
//    __/ /.'      /     Description:
//   __   \       /    
//  /_/ /\ \_____/ /     
// ____/  \_______/      
//
// *******************************
// Revisions:
// 0.0 Initial rev
//
// *******************************

module `IP_MODULE_NAME(bram_primitive) #(
	parameter FAMILY = "TITANIUM",	
	
	//Trion and Titanium parameters 
	parameter WRITE_WIDTH	     = 16, 			// write width
	parameter WCLK_POLARITY      = 1'b1, 		//wclk polarity,  0:falling edge, 1:rising edge
	parameter WCLKE_POLARITY     = 1'b1, 		//wclke polarity, 0:active low, 1:active high
	parameter [0:0] WE_POLARITY	 = 1'b1, 		//we polarity,    0:active low, 1:active high
	parameter WRITE_MODE  	     = "READ_FIRST",//write mode,  	  "READ_FIRST" 	:Old memory content is read. (default)
										     	//			  	  "WRITE_FIRST" :Write data is passed to the read port.
										     	//				  "READ_UNKNOWN": Read and writes are unsynchronized, therefore, the results of the address can conflict.
	parameter READ_WIDTH	 = 16,   		// read width
	parameter RCLK_POLARITY  = 1'b1, 		// rclk polarity, 0:falling edge, 1:rising edge
	parameter RE_POLARITY    = 1'b1, 		// re polarity,	  0:active low  , 1:active high
	parameter OUTPUT_REG     = 1'b0, 		// Output register enable, 1:add pipe-line read register

	//Titanium extra paramters 
	parameter RST_POLARITY 	    = 1'b1,    	// rst polarity
	parameter RESET_RAM 	    = "ASYNC", 	// reset mode on ram,  "NONE": RST signals does not affect the RAM output.
											//					  "ASYNC": RAM output resets asynchronously to RCLK.
											//                     "SYNC": RAM output resets synchronously to RCLK. 
	parameter RESET_OUTREG 	    = "ASYNC", 	// reset mode on output register
											//					   "NONE": RST signals does not affect the RAM output register		
											//					  "ASYNC": RAM output register resets asynchronously to RCLK.
	parameter WADDREN_POLARITY  = 1'b1,    	// waddren polarity
	parameter RADDREN_POLARITY  = 1'b1,   	// raddren polarity

	//Titanium Option for byte enable in WEN width = 2 when it is Mode 512x16 or  512x20
	parameter WEN_WIDTH			= 1,
	
	parameter ini_index	 		= 0
						
)   
(
	//Trion and Titanium ports
	WCLK, // Write clock input
	WCLKE, // Write clock-enable input
	WE,    // Write-enable input
	WADDR, // Write address input
	WDATA, // Write data input
	
	RCLK, 	// Read clock input
	RE, 		// Read-enable input
	RADDR, // Read address input
	RDATA, // Read data output

	//Titanium extra ports
    RST, 	  // reset	
	WADDREN,  // write address enable
	RADDREN  // read address enable
						
 );
function integer address_map;
input integer index;//Input data width parameter 
input integer type_; //Mapped data width, Mapped Address Width for Ram 5K(Trion), Mapped Address Width for Ram 10K(Titanium), WEN width for Ram 5K(Trion),  WEN width for Ram 10K(Titanium)
case (index)
0	: address_map=	(type_==0)?	1	:(type_==1)?	12	:(type_==2)?	13	:1;
1	: address_map=	(type_==0)?	1	:(type_==1)?	12	:(type_==2)?	13	:1;
2	: address_map=	(type_==0)?	2	:(type_==1)?	11	:(type_==2)?	12	:1;
3	: address_map=	(type_==0)?	4	:(type_==1)?	10	:(type_==2)?	11	:1;
4	: address_map=	(type_==0)?	4	:(type_==1)?	10	:(type_==2)?	11	:1;
5	: address_map=	(type_==0)?	5	:(type_==1)?	10	:(type_==2)?	11	:1;
6	: address_map=	(type_==0)?	8	:(type_==1)?	9	:(type_==2)?	10	:1;
7	: address_map=	(type_==0)?	8	:(type_==1)?	9	:(type_==2)?	10	:1;
8	: address_map=	(type_==0)?	8	:(type_==1)?	9	:(type_==2)?	10	:1;
9	: address_map=	(type_==0)?	10	:(type_==1)?	9	:(type_==2)?	10	:1;
10	: address_map=	(type_==0)?	10	:(type_==1)?	9	:(type_==2)?	10	:1;
11	: address_map=	(type_==0)?	16	:(type_==1)?	8	:(type_==2)?	9	:1;
12	: address_map=	(type_==0)?	16	:(type_==1)?	8	:(type_==2)?	9	:1;
13	: address_map=	(type_==0)?	16	:(type_==1)?	8	:(type_==2)?	9	:1;
14	: address_map=	(type_==0)?	16	:(type_==1)?	8	:(type_==2)?	9	:1;
15	: address_map=	(type_==0)?	16	:(type_==1)?	8	:(type_==2)?	9	:1;
16	: address_map=	(type_==0)?	16	:(type_==1)?	8	:(type_==2)?	9	:1;
17	: address_map=	(type_==0)?	20	:(type_==1)?	8	:(type_==2)?	9	:1;
18	: address_map=	(type_==0)?	20	:(type_==1)?	8	:(type_==2)?	9	:1;
19	: address_map=	(type_==0)?	20	:(type_==1)?	8	:(type_==2)?	9	:1;
20	: address_map=	(type_==0)?	20	:(type_==1)?	8	:(type_==2)?	9	:1;
   endcase
endfunction  

localparam  WRITE_DATA_WIDTH		= 	address_map(WRITE_WIDTH,0);
localparam  WRITE_ADDRESS_WIDTH     = 	address_map(WRITE_WIDTH,(FAMILY=="TRION")?1:2);

localparam  READ_DATA_WIDTH			= 	address_map(READ_WIDTH,0);
localparam  READ_ADDRESS_WIDTH     	= 	address_map(READ_WIDTH,(FAMILY=="TRION")?1:2);


//Trion and Titanium ports
input WCLK;  // Write clock input
input WCLKE; // Write clock-enable input
input [WEN_WIDTH-1:0] WE; 	 // Write-enable input
input [WRITE_ADDRESS_WIDTH-1:0] WADDR; // Write address input
input [WRITE_DATA_WIDTH-1:0] WDATA; // Write data input
	
input RCLK;  // Read clock input
input RE; 	 // Read-enable input
input [READ_ADDRESS_WIDTH-1:0] RADDR; // Read address input
output[READ_DATA_WIDTH-1:0]RDATA; // Read data output

//Titanium extra ports
input RST; 	  // reset	
input WADDREN;  // write address enable
input RADDREN;  // read address enable


`include "bram_ini.vh"

    generate 
    
		if (FAMILY=="TRION")
		begin
			EFX_RAM_5K # (
				.WRITE_WIDTH	(WRITE_WIDTH), 
				.WCLK_POLARITY  (WCLK_POLARITY), 
				.WCLKE_POLARITY (WCLKE_POLARITY), 
				.WE_POLARITY	(WE_POLARITY), 
				.WRITE_MODE  	(WRITE_MODE), 
															
				.READ_WIDTH	    (READ_WIDTH),
				.RCLK_POLARITY  (RCLK_POLARITY),
				.RE_POLARITY    (RE_POLARITY),
				.OUTPUT_REG     (OUTPUT_REG),
				
			
				.INIT_0  (bram_ini_table(ini_index,16'h0 )), 
				.INIT_1  (bram_ini_table(ini_index,16'h1 )),
				.INIT_2  (bram_ini_table(ini_index,16'h2 )),
				.INIT_3  (bram_ini_table(ini_index,16'h3 )),
				.INIT_4  (bram_ini_table(ini_index,16'h4 )),
				.INIT_5  (bram_ini_table(ini_index,16'h5 )),
				.INIT_6  (bram_ini_table(ini_index,16'h6 )),
				.INIT_7  (bram_ini_table(ini_index,16'h7 )),
				.INIT_8  (bram_ini_table(ini_index,16'h8 )),
				.INIT_9  (bram_ini_table(ini_index,16'h9 )),
				.INIT_A  (bram_ini_table(ini_index,16'hA )),
				.INIT_B  (bram_ini_table(ini_index,16'hB )),
				.INIT_C  (bram_ini_table(ini_index,16'hC )),
				.INIT_D  (bram_ini_table(ini_index,16'hD )),
				.INIT_E  (bram_ini_table(ini_index,16'hE )),
				.INIT_F  (bram_ini_table(ini_index,16'hF )),
				.INIT_10 (bram_ini_table(ini_index,16'h10)),
				.INIT_11 (bram_ini_table(ini_index,16'h11)),
				.INIT_12 (bram_ini_table(ini_index,16'h12)),
				.INIT_13 (bram_ini_table(ini_index,16'h13))
			) 
			 ram5k (
				.WCLK(WCLK), // Write clock input
				.WE(WE[0]), // Write-enable input
				.WCLKE(WCLKE), // Write clock-enable input
				.WADDR(WADDR), // Write address input
				.WDATA(WDATA), // Write data input

				.RCLK(RCLK), 	// Read clock input
				.RE(RE), 		// Read-enable input
				.RADDR(RADDR), // Read address input
				.RDATA(RDATA)  // Read data output
			);
		end 
		else 
		begin 
		
			wire [1:0]w_wen_ram10;
			assign w_wen_ram10[0] = WE[0];
			
			if (WEN_WIDTH>1)
				assign w_wen_ram10[1] = WE[1];
			else if (WRITE_DATA_WIDTH >= 16 )
				assign w_wen_ram10[1] = WE[0];
			else 	
				assign w_wen_ram10[1] = 1'b0;
			
			EFX_RAM10 # (
			
				.WRITE_WIDTH	(WRITE_WIDTH), 
				.WCLK_POLARITY  (WCLK_POLARITY), 
				.WCLKE_POLARITY (WCLKE_POLARITY), 
				.WE_POLARITY	({2{WE_POLARITY}}), 
				.WRITE_MODE  	(WRITE_MODE), 
															
				.READ_WIDTH	    (READ_WIDTH),
				.RCLK_POLARITY  (RCLK_POLARITY),
				.RE_POLARITY    (RE_POLARITY),
				.OUTPUT_REG     (OUTPUT_REG),
			
				//Titanium extra paramters 
				.RST_POLARITY 	(RST_POLARITY),    // rst polarity
				.RESET_RAM 	    (RESET_RAM), // reset mode on ram
				.RESET_OUTREG 	(RESET_OUTREG), // reset mode on output register
				.WADDREN_POLARITY  (WADDREN_POLARITY),    // waddren polarity
				.RADDREN_POLARITY  (RADDREN_POLARITY),     // raddren polarity
				
				
				.INIT_0  (bram_ini_table(ini_index, 16'h0 )), 
				.INIT_1  (bram_ini_table(ini_index, 16'h1 )),
				.INIT_2  (bram_ini_table(ini_index, 16'h2 )),
				.INIT_3  (bram_ini_table(ini_index, 16'h3 )),
				.INIT_4  (bram_ini_table(ini_index, 16'h4 )),
				.INIT_5  (bram_ini_table(ini_index, 16'h5 )),
				.INIT_6  (bram_ini_table(ini_index, 16'h6 )),
				.INIT_7  (bram_ini_table(ini_index, 16'h7 )),
				.INIT_8  (bram_ini_table(ini_index, 16'h8 )),
				.INIT_9  (bram_ini_table(ini_index, 16'h9 )),
				.INIT_A  (bram_ini_table(ini_index, 16'hA )),
				.INIT_B  (bram_ini_table(ini_index, 16'hB )),
				.INIT_C  (bram_ini_table(ini_index, 16'hC )),
				.INIT_D  (bram_ini_table(ini_index, 16'hD )),
				.INIT_E  (bram_ini_table(ini_index, 16'hE )),
				.INIT_F  (bram_ini_table(ini_index, 16'hF )),
				.INIT_10 (bram_ini_table(ini_index, 16'h10)),
				.INIT_11 (bram_ini_table(ini_index, 16'h11)),
				.INIT_12 (bram_ini_table(ini_index, 16'h12)),
				.INIT_13 (bram_ini_table(ini_index, 16'h13)),
				.INIT_14 (bram_ini_table(ini_index, 16'h14)),
				.INIT_15 (bram_ini_table(ini_index, 16'h15)),
				.INIT_16 (bram_ini_table(ini_index, 16'h16)),
				.INIT_17 (bram_ini_table(ini_index, 16'h17)),
				.INIT_18 (bram_ini_table(ini_index, 16'h18)),
				.INIT_19 (bram_ini_table(ini_index, 16'h19)),
				.INIT_1A (bram_ini_table(ini_index, 16'h1A)),
				.INIT_1B (bram_ini_table(ini_index, 16'h1B)),
				.INIT_1C (bram_ini_table(ini_index, 16'h1C)),
				.INIT_1D (bram_ini_table(ini_index, 16'h1D)),
				.INIT_1E (bram_ini_table(ini_index, 16'h1E)),
				.INIT_1F (bram_ini_table(ini_index, 16'h1F)),
				.INIT_20 (bram_ini_table(ini_index, 16'h20)),
				.INIT_21 (bram_ini_table(ini_index, 16'h21)),
				.INIT_22 (bram_ini_table(ini_index, 16'h22)),
				.INIT_23 (bram_ini_table(ini_index, 16'h23)),
				.INIT_24 (bram_ini_table(ini_index, 16'h24)),
				.INIT_25 (bram_ini_table(ini_index, 16'h25)),
				.INIT_26 (bram_ini_table(ini_index, 16'h26)),
				.INIT_27 (bram_ini_table(ini_index, 16'h27))
		
			)
			ram10k(
			
				.WCLK(WCLK), // Write clock input
				.WE(w_wen_ram10), // Write-enable input
				.WCLKE(WCLKE), // Write clock-enable input
				.WADDR(WADDR), // Write address input
				.WDATA(WDATA), // Write data input
							
				.RCLK(RCLK), 	// Read clock input
				.RE(RE), 		// Read-enable input
				.RADDR(RADDR), // Read address input
				.RDATA(RDATA), // Read data output
			
                //Titanium extra ports 
				.RST (RST), 		// reset
				.WADDREN (WADDREN), // write address enable
				.RADDREN (RADDREN)  // read address enable

			);
		end
	endgenerate 
      
endmodule


////////////////////////////////////////////////////////////////////////////
//           _____       
//          / _______    Copyright (C) 2013-2022 Efinix Inc. All rights reserved.
//         / /       \   
//        / /  ..    /   tb_top.v
//       / / .'     /    
//    __/ /.'      /     Description:
//   __   \       /    
//  /_/ /\ \_____/ /     
// ____/  \_______/      
//
// *******************************
// Revisions:
// 0.0 Initial rev
// Modified on 23 September  2022
// *******************************

module `IP_MODULE_NAME(bram_wrapper_mwm) #(
	parameter FAMILY = "TITANIUM",	
	
	//Trion and Titanium parameters 
	parameter WCLK_POLARITY  = 1'b1, 		//wclk polarity,  0:falling edge, 1:rising edge
	parameter WCLKE_POLARITY = 1'b1, 		//wclke polarity, 0:active low, 1:active high
	parameter WE_POLARITY	 = 1'b1, 		//we polarity,    0:active low, 1:active high
	parameter WRITE_MODE  	 = "READ_FIRST",//write mode,  	  "READ_FIRST" 	:Old memory content is read. (default)
											//			  	  "WRITE_FIRST" :Write data is passed to the read port.
											//				  "READ_UNKNOWN": Read and writes are unsynchronized, therefore, the results of the address can conflict.
	parameter RCLK_POLARITY  = 1'b1, 		// rclk polarity, 0:falling edge, 1:rising edge
	parameter RE_POLARITY    = 1'b1, 		// re polarity,	  0:active low  , 1:active high
	parameter OUTPUT_REG     = 1'b0, 		// Output register enable, 1:add pipe-line read register
	
    parameter BYTEEN_POLARITY   = 1'b1,     // byteen polarity		0:active low, 1:active high 
	
	//Titanium extra paramters 
	parameter RST_POLARITY 	    = 1'b1,    	// rst polarity
	parameter RESET_RAM 	    = "ASYNC", 	// reset mode on ram,  "NONE": RST signals does not affect the RAM output.
											//					  "ASYNC": RAM output resets asynchronously to RCLK.
											//                     "SYNC": RAM output resets synchronously to RCLK. 
	parameter RESET_OUTREG 	    = "ASYNC", 	// reset mode on output register
											//					   "NONE": RST signals does not affect the RAM output register		
											//					  "ASYNC": RAM output register resets asynchronously to RCLK.
	parameter WADDREN_POLARITY  = 1'b1,    	// waddren polarity
	parameter RADDREN_POLARITY  = 1'b1,    	// raddren polarity
	
	parameter DATA_WIDTH_A          = 16,
	parameter DATA_WIDTH_B          = 16,
	parameter ADDR_WIDTH_A          = 4,
	parameter ADDR_WIDTH_B          = 4,
	parameter BYTEEN_WIDTH          = 2
    
)   
(
	//Trion and Titanium ports
	wclk, 		// Write clock input
	wclke,		// Write clock-enable input
    byteen,		// Byteen input 
    we, 		// Write-enable input
    waddr, 		// Write address input
    wdata,		// Write data input
  
	rclk, 		// Read clock input	
    re, 		// Read-enable input
    raddr, 		// Read address input
    rdata, 		// Read data output     
     
	//Titanium extra ports
	reset,		 // reset	
	waddren,	 // write address enable
	raddren		 // read address enable
	
 );


`include "bram_decompose.vh"
//`include "bram_feature.vh"

input wclk; 
input wclke;
input we;
input [BYTEEN_WIDTH-1:0] byteen;
input [ADDR_WIDTH_A-1:0 ] waddr; 
input [DATA_WIDTH_A-1:0 ] wdata;

input rclk; 
input re; 
input [ADDR_WIDTH_B-1:0 ] raddr; 
output [DATA_WIDTH_B-1:0 ]rdata;     

input reset;
input waddren;
input raddren;

localparam MAP_ADDR_WIDTH_A = (address_mapping_table_A_size!=0)?address_mapping_table_A_size:ADDR_WIDTH_A;
localparam MAP_ADDR_WIDTH_B = (address_mapping_table_B_size!=0)?address_mapping_table_B_size:ADDR_WIDTH_B;

wire [MAP_ADDR_WIDTH_A-1:0 ] w_waddr_map; 
wire [DATA_WIDTH_A-1:0 ] w_wdata_map;

wire [MAP_ADDR_WIDTH_B-1:0 ] w_raddr_map; 
wire [DATA_WIDTH_B-1:0 ] w_rdata_map;

wire rclk_i;
wire wclk_i;
assign rclk_i = (RCLK_POLARITY == 1'b1)? rclk ~^ 1'b1: rclk ~^ 1'b0;
assign wclk_i = (WCLK_POLARITY == 1'b1)? wclk ~^ 1'b1: wclk ~^ 1'b0;

function integer get_current_row_index;
input integer row;//Mode type 
integer x;	
	begin
		get_current_row_index = 0;
		for (x=0; x<bram_mapping_size; x=x+1)
		begin
			if (bram_mapping_table(x,0) < row)
				get_current_row_index = get_current_row_index +1;
		end
	end 
endfunction 

function integer get_current_column_index;
input integer column;//Mode type 
integer x;	
	begin
		get_current_column_index = 0;
		for (x=0; x<bram_mapping_size; x=x+1)
		begin
			if (bram_mapping_table(x,1) < column)
				get_current_column_index = get_current_column_index +1;
		end
	end 
endfunction 


function integer get_max_mux_row_A;
input integer temp;//Mode type
integer x;	
	begin
		get_max_mux_row_A = 0;
		for (x=0; x<bram_mapping_size; x=x+1)
		begin
			if ( get_max_mux_row_A < bram_mapping_table(x,5) )
				get_max_mux_row_A =  bram_mapping_table(x,5);
		end
	end 
endfunction 

function integer get_max_wen_decode_A;
input integer temp;//Mode type
integer x;	
	begin
		get_max_wen_decode_A = 0;
		for (x=0; x<bram_mapping_size; x=x+1)
		begin
			if ( get_max_wen_decode_A < bram_mapping_table(x,6) )
				get_max_wen_decode_A =  bram_mapping_table(x,6);
		end
	end 
endfunction 


function integer get_max_mux_row_B;
input integer temp;//Mode type
integer x;	
	begin
		get_max_mux_row_B = 0;
		for (x=0; x<bram_mapping_size; x=x+1)
		begin
			if ( get_max_mux_row_B < bram_mapping_table(x,12) )
				get_max_mux_row_B =  bram_mapping_table(x,12);
		end
	end 
endfunction 

function integer get_max_wen_decode_B;
input integer temp;//Mode type
integer x;	
	begin
		get_max_wen_decode_B = 0;
		for (x=0; x<bram_mapping_size; x=x+1)
		begin
			if ( get_max_wen_decode_B < bram_mapping_table(x,13) )
				get_max_wen_decode_B =  bram_mapping_table(x,13);
		end
	end 
endfunction 



 //   localparam column_size = (bram_table_loop_mode==1)?bram_table_size:1;
   // wire [DATA_WIDTH_B-1:0] w_rdata [bram_table_size-1:0 ];
   // assign rdata = w_rdata[wdata];
    genvar gen_x;
    genvar gen_y;
	genvar gen_z;
	
    generate
			
		wire [DATA_WIDTH_B-1:0 ] rMux [get_max_mux_row_B(0):0]; 
		if (rMux_mapping_B_size == 0) 
        begin
            assign w_rdata_map = rMux[0]; 
        end 
        else 
        begin
            for (gen_y=0; gen_y<rMux_mapping_B_size; gen_y =gen_y +1)
            begin:rDataMux
                localparam ADDR_START = rMux_mapping_table_B(gen_y,1);
                localparam ADDR_END   = rMux_mapping_table_B(gen_y,0);
                
                localparam DATA_START = rMux_mapping_table_B(gen_y,3);
                localparam DATA_END   = rMux_mapping_table_B(gen_y,2);
				localparam BYPRASSED  = rMux_mapping_table_A(gen_y,6);
                
				if( BYPRASSED == 0 )
				begin 
				
					wire [ADDR_END:ADDR_START] rdSel = w_raddr_map[ADDR_END:ADDR_START];
					reg [ADDR_END:ADDR_START] r_rdSel_1P = {(ADDR_END-ADDR_START+1){1'b0}};
					wire w_raddren = FAMILY == "TRION" ? 1 : raddren ~^ RADDREN_POLARITY;	//addren port not exist in Trion, active high
					wire w_re = re ~^ RE_POLARITY;
					
					always @ (posedge rclk_i)
					begin
						if(w_re && w_raddren) 
							r_rdSel_1P <= rdSel;
					end
                    
                    
                    if (OUTPUT_REG == 0)
                    begin
                        assign w_rdata_map[DATA_END:DATA_START] = rMux[r_rdSel_1P][DATA_END:DATA_START];
                    end 
                    else 
                    begin
                        reg [ADDR_END:ADDR_START] r_rdSel_2P = {(ADDR_END-ADDR_START+1){1'b0}};
						assign w_rdata_map[DATA_END:DATA_START] = rMux[r_rdSel_2P][DATA_END:DATA_START];
						always @ (posedge rclk_i)
						begin
							if ((FAMILY == "TITANIUM" && w_re) || (FAMILY == "TRION"))
								r_rdSel_2P <= r_rdSel_1P;
						end
                    end 
                end 
				else 
				begin 
					assign w_rdata_map[DATA_END:DATA_START] = rMux[0][DATA_END:DATA_START];
				
				end 
            
            end
        end 
        
		wire [get_max_wen_decode_A(0):0] wen_decode ;
        if (wen_sel_mapping_A_size!=0)
        begin  
			for (gen_y=0; gen_y<wen_sel_mapping_A_size; gen_y =gen_y +1)
			begin:wDataEn
				localparam ADDR_START = wen_sel_mapping_table_A(gen_y,1);
				localparam ADDR_END   = wen_sel_mapping_table_A(gen_y,0);
				
				localparam SEL_START = wen_sel_mapping_table_A(gen_y,3);
				localparam SEL_END   = wen_sel_mapping_table_A(gen_y,2);
				
				localparam BYPRASSED  = wen_sel_mapping_table_A(gen_y,4);
				
				if( BYPRASSED == 0 )
				begin 
					wire [ADDR_END:ADDR_START] wrSel;
					reg [ADDR_END:ADDR_START]  r_wrSel = {(ADDR_END-ADDR_START+1){1'b0}};

					wire w_wclke = wclke ~^ WCLKE_POLARITY;   
					wire w_waddren = FAMILY == "TRION" ? 1 : waddren ~^ WADDREN_POLARITY;	//addren port not exist in Trion, active high
					wire w_wrSel_mux = w_wclke && w_waddren;
					
					always @ (posedge wclk_i)
					begin
						if(w_wclke && w_waddren) 
							r_wrSel <= w_waddr_map[ADDR_END:ADDR_START];
					end
				
					assign wrSel = (w_wrSel_mux==1'b1) ? w_waddr_map[ADDR_END:ADDR_START]: r_wrSel;
					
					for (gen_x=SEL_START; gen_x<(SEL_END+1); gen_x = gen_x +1)
					begin
						assign wen_decode[gen_x] = (wrSel==(gen_x-SEL_START))?1'b1:1'b0;
					end 
				end 
				else 
				begin
				
					for (gen_x=SEL_START; gen_x<(SEL_END+1); gen_x = gen_x +1)
					begin
						assign wen_decode[gen_x] = 1'b1;
					end 
				end 
			
			end
		end 
		else 
		begin 
			assign wen_decode = {(get_max_wen_decode_A(0)+1){1'b1}};
		end 
		
		
		//For Mixed Width Mode 
		if (data_mapping_table_A_size!=0)
        begin  
			for (gen_y=0; gen_y<data_mapping_table_A_size; gen_y = gen_y +1)
			begin
				assign w_wdata_map[data_mapping_table_A(gen_y)] =  wdata[gen_y] ;
			end
		end 
		else 
		begin 
			assign w_wdata_map = wdata;
		end 
	
		if (address_mapping_table_A_size!=0)
        begin  
			for (gen_y=0; gen_y<address_mapping_table_A_size; gen_y = gen_y +1)
			begin
				if (gen_y < ADDR_WIDTH_A)
					assign w_waddr_map[address_mapping_table_A(gen_y)] =  waddr[gen_y] ;
				else 
					assign w_waddr_map[address_mapping_table_A(gen_y)] =  1'b0 ;
			end
		end 
		else 
		begin 
			assign w_waddr_map = waddr;
		end 
	
	
		if (data_mapping_table_B_size!=0)
        begin  
			for (gen_y=0; gen_y<data_mapping_table_B_size; gen_y = gen_y +1)
			begin
				assign rdata[gen_y]  = w_rdata_map[data_mapping_table_B(gen_y)] ;
			end
		end 
		else 
		begin 
			assign rdata = w_rdata_map;
		end 
	
		if (address_mapping_table_B_size!=0)
        begin  
			for (gen_y=0; gen_y<address_mapping_table_B_size; gen_y = gen_y +1)
			begin
				if (gen_y < ADDR_WIDTH_B)
					assign w_raddr_map[address_mapping_table_B(gen_y)] =  raddr[gen_y] ;
				else 
					assign w_raddr_map[address_mapping_table_B(gen_y)] =  1'b0;		
			end
			
		end 
		else 
		begin 
			assign w_raddr_map = raddr;
		end 
			
			
		if (bram_table_loop_mode == 0 ) 
		begin:scan_column
			for (gen_x=0; gen_x<bram_table_size; gen_x =gen_x +1)
			begin:column
				localparam bram_mode_a = bram_decompose_table(gen_x,0); 
				localparam bram_mode_b = bram_decompose_table(gen_x,1); 
				localparam row_count = bram_decompose_table(gen_x,2);
			
				localparam WADDR_WIDTH_ROW = bram_feature_table(bram_mode_a,0);
				localparam WDATA_WIDTH_ROW = bram_feature_table(bram_mode_a,1); 
				localparam WEN_WIDTH_ROW   = bram_feature_table(bram_mode_a,2); 
				
				localparam RADDR_WIDTH_ROW = bram_feature_table(bram_mode_b,0);
				localparam RDATA_WIDTH_ROW = bram_feature_table(bram_mode_b,1); 
				
				localparam START_COLUMN_INDEX = get_current_column_index(gen_x);
				
										
				for (gen_y=0; gen_y<row_count; gen_y =gen_y +1)
				begin:row
					
					localparam DATA_MAP_INDEX = START_COLUMN_INDEX+gen_y;

					localparam WDATA_END     = bram_mapping_table(DATA_MAP_INDEX,2);					
					localparam WDATA_START   = bram_mapping_table(DATA_MAP_INDEX,3);
					localparam WDATA_REPART  = bram_mapping_table(DATA_MAP_INDEX,4);
					localparam WRSEL_INDEX   = bram_mapping_table(DATA_MAP_INDEX,6);
					localparam BYTEEN_INDEX  = bram_mapping_table(DATA_MAP_INDEX,8);
					
					localparam RDATA_END     = bram_mapping_table(DATA_MAP_INDEX,9);
					localparam RDATA_START   = bram_mapping_table(DATA_MAP_INDEX,10);
					localparam RDATA_REPART  = bram_mapping_table(DATA_MAP_INDEX,11);
					localparam RMUX_INDEX    = bram_mapping_table(DATA_MAP_INDEX,12);
					
					wire [WADDR_WIDTH_ROW-1:0] w_waddr;
					wire [WDATA_WIDTH_ROW-1:0] w_wdata;
					wire [WEN_WIDTH_ROW-1:0]   w_we;

					wire [RADDR_WIDTH_ROW-1:0] w_raddr;
					wire [RDATA_WIDTH_ROW-1:0] w_rdata;
					
					//assign w_waddr[WADDR_WIDTH_ROW-1:0] = w_waddr_map[WADDR_WIDTH_ROW-1:0];
					//assign w_raddr[RADDR_WIDTH_ROW-1:0] = w_raddr_map[RADDR_WIDTH_ROW-1:0];	
                    
					for(gen_z=0;gen_z<WADDR_WIDTH_ROW; gen_z=gen_z+1)
					begin
						if(gen_z< ADDR_WIDTH_A) 
							assign w_waddr[gen_z] = w_waddr_map[gen_z];
						else
							assign w_waddr[gen_z] = 1'b0;
					end
					
					for(gen_z=0;gen_z<RADDR_WIDTH_ROW; gen_z=gen_z+1)
					begin
						if(gen_z< ADDR_WIDTH_B) 
							assign w_raddr[gen_z] = w_raddr_map[gen_z];
						else
							assign w_raddr[gen_z] = 1'b0;			
					
					end
					
					
					if (WDATA_REPART == 0)
					begin
						assign w_wdata[WDATA_WIDTH_ROW-1:0] = w_wdata_map[WDATA_END:WDATA_START];
					end
					else 
					begin
						//for Mixed Width Mode 
						for (gen_z=0; gen_z<WDATA_REPART; gen_z = gen_z+1)
						begin
							localparam MIXED_WDATA_START =  WDATA_START + gen_z*row_count*(RDATA_END - RDATA_START+1); //RDATA_WIDTH_ROW;
							localparam MIXED_WDATA_END   =  WDATA_END   + gen_z*row_count*(RDATA_END - RDATA_START+1); //RDATA_WIDTH_ROW; 
							
							localparam MAPPED_WDATA_START =  RDATA_WIDTH_ROW* gen_z;
							localparam MAPPED_WDATA_END   =  RDATA_WIDTH_ROW*(gen_z+1) -1; 
							
							assign w_wdata[MAPPED_WDATA_END: MAPPED_WDATA_START]  =  w_wdata_map[MIXED_WDATA_END:MIXED_WDATA_START];
						end
					end 
	
					if (RDATA_REPART == 0)
					begin
						assign rMux[RMUX_INDEX][RDATA_END:RDATA_START]   = w_rdata[RDATA_WIDTH_ROW-1:0];
					end 
					else 
					begin
						//for Mixed Width Mode 
						for (gen_z=0; gen_z<RDATA_REPART; gen_z = gen_z+1)
						begin
							localparam MIXED_RDATA_START =  RDATA_START + gen_z*row_count*(WDATA_END - WDATA_START+1); //WDATA_WIDTH_ROW;
							localparam MIXED_RDATA_END   =  RDATA_END   + gen_z*row_count*(WDATA_END - WDATA_START+1); //WDATA_WIDTH_ROW; 
							
							localparam MAPPED_RDATA_START =  RDATA_WIDTH_ROW* gen_z;
							localparam MAPPED_RDATA_END   =  RDATA_WIDTH_ROW*(gen_z+1) -1; 
							
							assign rMux[RMUX_INDEX][MIXED_RDATA_END:MIXED_RDATA_START]   = w_rdata[MAPPED_RDATA_END:MAPPED_RDATA_START];  
						end					
					end 					
							
					assign w_we[0] = ((we == WE_POLARITY) & wen_decode[WRSEL_INDEX] & (byteen[BYTEEN_INDEX] == BYTEEN_POLARITY) )? WE_POLARITY: !WE_POLARITY;
					if ( WEN_WIDTH_ROW >1)
					begin
						assign w_we[1] = ((we == WE_POLARITY) & wen_decode[WRSEL_INDEX] & (byteen[BYTEEN_INDEX] == BYTEEN_POLARITY) ) ? WE_POLARITY: !WE_POLARITY;
					end 		
					
					`IP_MODULE_NAME(bram_primitive) #(
						.FAMILY(FAMILY),	
						
						//Trion and Titanium parameters 
						.WRITE_WIDTH(WDATA_WIDTH_ROW),	
						.WCLK_POLARITY(WCLK_POLARITY), 	
						.WCLKE_POLARITY(WCLKE_POLARITY),
						.WE_POLARITY(WE_POLARITY), 		
						.WRITE_MODE(WRITE_MODE),		
														
						.READ_WIDTH(RDATA_WIDTH_ROW),  
						.RCLK_POLARITY(RCLK_POLARITY), 	
						.RE_POLARITY(RE_POLARITY), 		
						.OUTPUT_REG(OUTPUT_REG),
						
						//Titanium extra paramters 
						.RST_POLARITY(RST_POLARITY),   	
						.RESET_RAM(RESET_RAM), 			
						.RESET_OUTREG(RESET_OUTREG), 	
						.WADDREN_POLARITY(WADDREN_POLARITY),
						.RADDREN_POLARITY(RADDREN_POLARITY),
						
						.WEN_WIDTH(WEN_WIDTH_ROW),
						
						.ini_index(DATA_MAP_INDEX)
								
					) bram (
						//Trion and Titanium ports
						.WCLK(wclk), 	// Write clock input
						.WCLKE(wclke),	// Write clock-enable input
						.WE(w_we), 		// Write-enable input
						.WADDR(w_waddr),  // Write address input
						.WDATA(w_wdata), // Write data input
						
						.RCLK(rclk), 	// Read clock input
						.RE(re), 		// Read-enable input
						.RADDR(w_raddr),  // Read address input
						.RDATA(w_rdata), // Read data output
					
						//Titanium extra ports
						.RST(reset), 	   // reset	
						.WADDREN(waddren), // write address enable
						.RADDREN(raddren)  // read address enable					
					);
				end
			end
			
		end
		else if (bram_table_loop_mode == 1 ) 
		begin:scan_row
			
			for (gen_y=0; gen_y<bram_table_size; gen_y =gen_y +1)
			begin:row
				localparam bram_mode_a = bram_decompose_table(gen_y,0); 
				localparam bram_mode_b = bram_decompose_table(gen_y,1); 
				localparam column_count = bram_decompose_table(gen_y,2);
			
				localparam WADDR_WIDTH_ROW = bram_feature_table(bram_mode_a,0);
				localparam WDATA_WIDTH_ROW = bram_feature_table(bram_mode_a,1); 
				localparam WEN_WIDTH_ROW   = bram_feature_table(bram_mode_a,2); 
				
				localparam RADDR_WIDTH_ROW = bram_feature_table(bram_mode_b,0);
				localparam RDATA_WIDTH_ROW = bram_feature_table(bram_mode_b,1); 
				
				localparam START_ROW_INDEX = get_current_row_index(gen_y);
				
										
				for (gen_x=0; gen_x<column_count; gen_x =gen_x +1)
				begin:column
					
					localparam DATA_MAP_INDEX = START_ROW_INDEX+gen_x;
										
					localparam WDATA_END     = bram_mapping_table(DATA_MAP_INDEX,2);					
					localparam WDATA_START   = bram_mapping_table(DATA_MAP_INDEX,3);
					localparam WDATA_REPART  = bram_mapping_table(DATA_MAP_INDEX,4);
					localparam WRSEL_INDEX   = bram_mapping_table(DATA_MAP_INDEX,6);
					localparam BYTEEN_INDEX  = bram_mapping_table(DATA_MAP_INDEX,8);
					
					localparam RDATA_END     = bram_mapping_table(DATA_MAP_INDEX,9);
					localparam RDATA_START   = bram_mapping_table(DATA_MAP_INDEX,10);
					localparam RDATA_REPART  = bram_mapping_table(DATA_MAP_INDEX,11);
					localparam RMUX_INDEX    = bram_mapping_table(DATA_MAP_INDEX,12);
					
					
					wire [WADDR_WIDTH_ROW-1:0] w_waddr;
					wire [WDATA_WIDTH_ROW-1:0] w_wdata;
					wire [WEN_WIDTH_ROW-1:0]   w_we;

					wire [RADDR_WIDTH_ROW-1:0] w_raddr;
					wire [RDATA_WIDTH_ROW-1:0] w_rdata;
					
                    
					for(gen_z=0;gen_z<WADDR_WIDTH_ROW; gen_z=gen_z+1)
					begin
						if(gen_z< ADDR_WIDTH_A) 
							assign w_waddr[gen_z] = w_waddr_map[gen_z];
						else
							assign w_waddr[gen_z] = 1'b0;
					end
					
					for(gen_z=0;gen_z<RADDR_WIDTH_ROW; gen_z=gen_z+1)
					begin
						if(gen_z< ADDR_WIDTH_B) 
							assign w_raddr[gen_z] = w_raddr_map[gen_z];
						else
							assign w_raddr[gen_z] = 1'b0;			
					
					end
                    
                    
					
					if (WDATA_REPART == 0)
					begin
						assign w_wdata[WDATA_WIDTH_ROW-1:0] = w_wdata_map[WDATA_END:WDATA_START];
					end
					else 
					begin
						//for Mixed Width Mode 
						for (gen_z=0; gen_z<WDATA_REPART; gen_z = gen_z+1)
						begin:MIXED_WIDTH_MAPPING
							localparam MIXED_WDATA_START =  WDATA_START + gen_z*column_count*(RDATA_END - RDATA_START+1); // RDATA_WIDTH_ROW;
							localparam MIXED_WDATA_END   =  WDATA_END   + gen_z*column_count*(RDATA_END - RDATA_START+1); //RDATA_WIDTH_ROW; 
							
							localparam MAPPED_WDATA_START =  RDATA_WIDTH_ROW* gen_z;
							localparam MAPPED_WDATA_END   =  RDATA_WIDTH_ROW*(gen_z+1) -1; 
							
							
							assign w_wdata[MAPPED_WDATA_END: MAPPED_WDATA_START]  =  w_wdata_map[MIXED_WDATA_END:MIXED_WDATA_START];
						end
					end 
	
					if (RDATA_REPART == 0)
					begin
						assign rMux[RMUX_INDEX][RDATA_END:RDATA_START]   = w_rdata[RDATA_WIDTH_ROW-1:0];
					end 
					else 
					begin
						//for Mixed Width Mode 
						for (gen_z=0; gen_z<RDATA_REPART; gen_z = gen_z+1)
						begin:MIXED_WIDTH_MAPPING
							localparam MIXED_RDATA_START =  RDATA_START + gen_z*column_count*(WDATA_END - WDATA_START+1); //WDATA_WIDTH_ROW;
							localparam MIXED_RDATA_END   =  RDATA_END   + gen_z*column_count*(WDATA_END - WDATA_START+1); //WDATA_WIDTH_ROW; 
							
							localparam MAPPED_RDATA_START =  WDATA_WIDTH_ROW* gen_z;
							localparam MAPPED_RDATA_END   =  WDATA_WIDTH_ROW*(gen_z+1) -1; 
							
							
							assign rMux[RMUX_INDEX][MIXED_RDATA_END:MIXED_RDATA_START]   = w_rdata[MAPPED_RDATA_END:MAPPED_RDATA_START];  
						end					
					end 					
					
					
					
                     
					assign w_we[0] = ((we == WE_POLARITY) & wen_decode[WRSEL_INDEX] & (byteen[BYTEEN_INDEX] == BYTEEN_POLARITY)) ? WE_POLARITY: !WE_POLARITY;
					if ( WEN_WIDTH_ROW >1)
					begin
						assign w_we[1] = ((we == WE_POLARITY) & wen_decode[WRSEL_INDEX] & (byteen[BYTEEN_INDEX] == BYTEEN_POLARITY)) ? WE_POLARITY: !WE_POLARITY;
					end 
									
					`IP_MODULE_NAME(bram_primitive) #(
						.FAMILY(FAMILY),	
						
						//Trion and Titanium parameters 
						.WRITE_WIDTH(WDATA_WIDTH_ROW),	
						.WCLK_POLARITY(WCLK_POLARITY), 	
						.WCLKE_POLARITY(WCLKE_POLARITY),
						.WE_POLARITY(WE_POLARITY), 		
						.WRITE_MODE(WRITE_MODE),		
														
						.READ_WIDTH(RDATA_WIDTH_ROW),  
						.RCLK_POLARITY(RCLK_POLARITY), 	
						.RE_POLARITY(RE_POLARITY), 		
						.OUTPUT_REG(OUTPUT_REG),	
						
						//Titanium extra paramters 
						.RST_POLARITY(RST_POLARITY),   	
						.RESET_RAM(RESET_RAM), 			
						.RESET_OUTREG(RESET_OUTREG), 	
						.WADDREN_POLARITY(WADDREN_POLARITY),
						.RADDREN_POLARITY(RADDREN_POLARITY),
						
						.WEN_WIDTH(WEN_WIDTH_ROW),
						
						.ini_index(DATA_MAP_INDEX)
								
					) bram (
						//Trion and Titanium ports
						.WCLK(wclk), 	// Write clock input
						.WCLKE(wclke),	// Write clock-enable input
						.WE(w_we), 		// Write-enable input
						.WADDR(w_waddr),  // Write address input
						.WDATA(w_wdata), // Write data input
						
						.RCLK(rclk), 	// Read clock input
						.RE(re), 		// Read-enable input
						.RADDR(w_raddr),  // Read address input
						.RDATA(w_rdata), // Read data output
					
						//Titanium extra ports
						.RST(reset), 	   // reset	
						.WADDREN(waddren), // write address enable
						.RADDREN(raddren)  // read address enable					
					);
				end
			end
 
		end 
    endgenerate 
 
 
endmodule


////////////////////////////////////////////////////////////////////////////
//           _____       
//          / _______    Copyright (C) 2013-2022 Efinix Inc. All rights reserved.
//         / /       \   
//        / /  ..    /   `IP_MODULE_NAME(efx_single_port_ram).v
//       / / .'     /    
//    __/ /.'      /     Description:
//   __   \       /    
//  /_/ /\ \_____/ /     
// ____/  \_______/      
//
// *******************************
// Revisions:
// 0.0 Initial rev
//
// *******************************

module `IP_MODULE_NAME(efx_single_port_rom) (
	//Trion and Titanium ports
	clk,		// clock input for one clock mode
	addr, 		// address input

  
    re, 		// Read-enable input
    rdata_a, 	// Read data output     
     
	//Titanium extra ports
	reset,		 // reset	
	addren	     // address enable
 );

//`include "bram_decompose.vh"

//Trion and Titanium parameters 
parameter CLK_POLARITY  = 1'b1; 		//clk polarity;  0:falling edge; 1:rising edge

parameter RE_POLARITY    = 1'b1; 		// re polarity;	  0:active low  ; 1:active high
parameter OUTPUT_REG     = 1'b0; 		// Output register enable; 1:add pipe-line read register

parameter RE_ENABLE 		= 1'b1;		//1: Enable  the port for RE pin ; 0: disable 


//Titanium extra paramters 
parameter RST_POLARITY 	    = 1'b1;    	// rst polarity
parameter RESET_RAM 	    = "ASYNC"; 	// reset mode on ram;  "NONE": RST signals does not affect the RAM output.
										//					  "ASYNC": RAM output resets asynchronously to RCLK.
										//                     "SYNC": RAM output resets synchronously to RCLK. 
parameter RESET_OUTREG 	    = "ASYNC"; 	// reset mode on output register
										//					   "NONE": RST signals does not affect the RAM output register		
										//					  "ASYNC": RAM output register resets asynchronously to RCLK.
parameter ADDREN_POLARITY  = 1'b1;    	// addren polarity


//Port Enable  
parameter RESET_ENABLE 		= 1'b1;		//1: Enable  the port for reset pin  ; 0: disable 
	
parameter ADDREN_ENABLE 	= 1'b1;		//1: Enable  the port for addren pin  ; 0: disable 

parameter WRITE_MODE        = "READ_FIRST";

parameter FAMILY     = "TITANIUM";

parameter DATA_WIDTH_A      = 16;
parameter ADDR_WIDTH_A      = 3;
parameter BYTEEN_WIDTH      = 2;

//Trion and Titanium ports
input clk;
input [ADDR_WIDTH_A-1:0] addr;

input re; 
output [DATA_WIDTH_A-1:0] rdata_a;

//Titanium extra ports
input reset;	
input addren;

wire w_wclk;
wire w_rclk;
wire w_wclke;
wire [BYTEEN_WIDTH-1:0] w_byteen;

wire w_re;
wire w_reset;
wire w_addren;

assign w_re   = (RE_ENABLE==1)  ? re : RE_POLARITY;

//Titanium extra ports
assign w_reset   = (RESET_ENABLE==1)  ? reset   : (RST_POLARITY==1'b1) ? 1'b0: 1'b1;
assign w_addren = (ADDREN_ENABLE==1)? addren : ADDREN_POLARITY;

 	`IP_MODULE_NAME(bram_wrapper_mwm) #(
		//Trion and Titanium parameters 
		.WCLK_POLARITY(1'b1), 	
		.WCLKE_POLARITY(1'b1),
		.WE_POLARITY(1'b1), 		
		.WRITE_MODE("READ_FIRST"),		
				
		.RCLK_POLARITY(CLK_POLARITY), 	
		.RE_POLARITY(RE_POLARITY), 		
		.OUTPUT_REG(OUTPUT_REG),	
		
		.DATA_WIDTH_A(DATA_WIDTH_A),
		.DATA_WIDTH_B(DATA_WIDTH_A),
		.ADDR_WIDTH_A(ADDR_WIDTH_A),
		.ADDR_WIDTH_B(ADDR_WIDTH_A),
		.BYTEEN_WIDTH(BYTEEN_WIDTH),
		.FAMILY(FAMILY),
		
		.BYTEEN_POLARITY(1'b1),
		
		//Titanium extra paramters 
		.RST_POLARITY(RST_POLARITY),   	
		.RESET_RAM(RESET_RAM), 			
		.RESET_OUTREG(RESET_OUTREG), 	
		.WADDREN_POLARITY(ADDREN_POLARITY),
		.RADDREN_POLARITY(ADDREN_POLARITY) 
		
	) brams (
		.wclk(clk), 
		.wclke(1'b1),
		.we(1'b0), 
		.byteen({BYTEEN_WIDTH{1'b0}}),
        
        .waddr({ADDR_WIDTH_A{1'b0}}), 
		.wdata({DATA_WIDTH_A{1'b0}}),
          
		.rclk(clk), 
		.re(w_re), 
		.raddr(addr), 
		.rdata(rdata_a),
		      
        
		//Titanium extra ports
		.reset(w_reset), 	// reset	
		.waddren(w_addren), // write address enable
		.raddren(w_addren)  // read address enable	
	);
 
 
endmodule
`undef IP_UUID
`undef IP_NAME_CONCAT
`undef IP_MODULE_NAME
